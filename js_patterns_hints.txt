1. Избегать засорения глобального пространства имен.
2. Избегать создания глобальных переменных
3. Объявлять переменные внутри функций, вначале.
4. В цикле for избегать вычисления длины массива (если используется) на каждой итерации. Исключение составляет случай когда длина массива или коллекции меняется за время выполенения цикла (большой + к производительности)
5. В цикле for сравнивать i с 0 (небольшой + к производительности)
6. В цикле for использовать декремент
7. Цикл for in использовать только для объектов.
8. При перечислении свойств в цикле for in выполнять проверку на то, является ли свойство объекта собственным или унаследовано прототипом. (- к производительности, следует использовать только когда нет уверенности в цепочке наследования объекта)
(function() {
  'use strict';
  var man = {
    hands: 2,
    legs: 2,
    heads: 1
  };
  
  if (typeof Object.prototype.clone === "undefined") {
    Object.prototype.clone = function () {};
  }
  
  for (var i in man) {
    if (man.hasOwnProperty(i)) {
      console.log( i + ": " + man[i])
    }
  }
}());

Иначе, можно вызвать метод отностиельно Object.prototype. Делается в случае если объект переопределил hasOwnProperty, позволяет избежать конфликтов имен

for (var i in man) {
	if (Object.prototype.hasOwnProperty.call(i, man)) {
		console.log(i, ": ", man[i]);
	}
}

Воизбежание поиска метода в списке свойств объекта Object следует сохранить ссылку на него в локальной переменной

var i,
	ownProp = Object.prototype.hasOwnProperty; 
for (i in man) {
	if (ownProp.call(man, i)) {
		console.log(i, ": ", man[i]);
	}
}
9. НЕ следует расширять встроенные прототипы. (- к поддерживаемости кода)
Исключения: 
- при ожидании, что данная функциональность вступит в силу в будущих версиях ECMAScriptX (ESX)
- когда есть уверенность, что собственное свойство или метод не реализован где-либо в другом месте и не явлется часть реализации JS в одном из поддерживаемых броузеров
- при наличии документации, сообщающей всем участникам проекта о подобных изменениях.
Добавление собственного метода в прототип объекта:

if (typeof Object.prototype.myMethod !== "function") {
	Object.prototype.myMethod = function () {};
}

10. В конструкции switch - case следует придерживаться следующи правил:
- каждая инструкция case завершается break
- при использовании "проваливания", что не желательно, необходимо обязательно комментировать этот участок кода, с пояснением того, что там происходит. Иначе, такой код может быть воспринят за ошибку при более позднем прочтении или при прочтении коллегами
- заканчивать инструкцию switch инструкцией default, для избежания неожиданных результатов

(function() {
  var inspect_me = 0,
      result = '';
  
  switch (inspect_me) {
  case 0:
      result = 'zero';
      break;
      
  case 1:
      result = 'one';
      break;
  
  default:
      result = 'unknown';
  }
  
  return result;
}());

11. Следует избегать неявного приведения типов 0 не равен false и при проверке такого равенства результатом должен быть false. Использовать оператор == можно при совместном использовании с typeof.

(function() {
  var zero = 0;
  
  if (zero === false) {
    console.log('это работать не будет');
  }
  
  console.log('0 не равен false!');
  
  if (zero == false) {
    console.log('Если это сработало, значит используется неявное приведение типов :(');
  }
  
  if (typeof zero == false) {
    console.log('Не выполнится');
  }
  
  console.log('Инструкция выше не выполнилась так как typeof zero вернет строку "number", что в свою очередь не равно false');
}());

12. Избегать использования функции eval() (большой "-" к безопасности)

13. Преобразование строки в число лучше всего производить с помощью функции parseInt() (- к производительности, т.к. происходит анализ переданных аргументов). Так же допустимо использование перобразование через оператор "+" или с помощью конструктора объектов Number(). 
При использовании функции parseInt(a, 10) следует указывать систему исчисления в которую нужно преобразовать строку. Делается это для исключения несоответствия между ECMAScript3 и ECMAScript5
Использование parseInt() предпочтительнее потому, что преобразование строки в число произойдет даже в случае когда строка состоит не только из числовых символов, в то время как "+" или Number() вернут NaN

(function() {
  var a = '09ad';
  
  console.log(parseInt(a, 10)); // 9
  console.log(+a);              // NaN
  console.log(Number(a));       // NaN
  
}());

14. Обязательно нужно выработать соглашения (styleguide) по оформлению программного кода и неукоснительно следовать им.
- соблюдать одноообразие в отступах
- всегда писать фигурные скобки в инструкциях if и циклах for
- открывающую фигурную скобку всегда ставить вконце строки. Это поможет избежать неожиданных результатов при выполнении кода.
Даная функция вернет undefined:

(function() {
  
  return 
  {
    a: 0
  }
  
}());

и эквивалентна следующей записи:

(function() {
  
  return undefined;
  {
    a: 0
  }
  
}());

напротив, такая запись вернет объект, как и ожидалось:

(function() {
  
  return {      // вернет Object { a=0}
    a: 0
  }
  
}());

- правильно использовать пробелы: 
а) После точек с запятой отделяющих части инструкции цикла for и при инициализации нескольких переменных в цикле. Например: for (var i = 10, max = 10; i > 0; i --, max += 4 ) {...}
б) После запятых, отделяющих элементы массива. Пример: var a = [1, 2, 3];
в) После запятых, отделяющих имена свойств объектов и после двоеточий, отделяющих имена свойств от их значений. Пример: var o = {a: 1, b: 2};
г) После запятых, отделяющих аргументы функций. Пример: myFunc(a, b, c)
д) Перед фигурными скобками в объявлениях функций. function myFunc() {}
е) После ключевого слова function в анонимных функциях. Пример: var myFunc = function () {}
ё) Отделять пробелами операторы от операндов
ж) Перед открывающими фигурными скобками в функциях и инструкциях if-else и switch
з) После закрывающей фигурной скобки в инструкциях else и while

- использовать псты строки для логического разделения когда, что существенно повышает читабельность.

15. 